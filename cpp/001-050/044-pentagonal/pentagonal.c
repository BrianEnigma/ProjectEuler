#include <stdio.h>
#include <string.h>
#include <stdlib.h>
//#include <math.h>
//#include <ctype.h>
#include <gmp.h>
/*
 * Pentagonal numbers are generated by the formula, P_(n)=n(3n-1)/2. The first
 * ten pentagonal numbers are:
 *
 * 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
 *
 * It can be seen that P_(4) + P_(7) = 22 + 70 = 92 = P_(8). However, their
 * difference, 70 - 22 = 48, is not pentagonal.
 *
 * Find the pair of pentagonal numbers, P_(j) and P_(k), for which their sum
 * and difference is pentagonal and D = |P_(k) - P_(j)| is minimised; what
 * is the value of D?
 *
 */

void printNumber(const char *s1, mpz_t n, const char *s2)
{
    printf("%s", s1);
    mpz_out_str(stdout, 10, n);
    printf("%s", s2);
}

// Given: p = (n(3n-1)/2
// Then: n = (sqrt(24p+1)+1)/6
// Therefore if 24p+1 isn't a perfect square, it's not pentagonal
// Also: if fraction doesn't resolve to integer, it's not pentagonal
char isPentagonal(mpz_t number)
{
    mpz_t p, remainder;
    mpz_init(p);
    mpz_init(remainder);
    mpz_mul_ui(p, number, 24);
    mpz_add_ui(p, p, 1);
    mpz_sqrtrem(p, remainder, p);
    if (mpz_cmp_ui(remainder, 0) != 0)
    {
        mpz_clear(p);
        mpz_clear(remainder);
        return 0;
    }
    mpz_add_ui(p, p, 1);
    mpz_tdiv_qr_ui(p, remainder, p, 6);
    if (mpz_cmp_ui(remainder, 0) != 0)
    {
        mpz_clear(p);
        mpz_clear(remainder);
        return 0;
    }
    mpz_clear(p);
    mpz_clear(remainder);
    return 1;
}

// p = (n(3n-1)/2
void pentagonal(mpz_t result, mpz_t n)
{
    mpz_init(result);
    mpz_mul_ui(result, n, 3);           // 3n
    mpz_sub_ui(result, result, 1);      // 3n-1
    mpz_mul(result, result, n);         // n(3n-1)
    mpz_tdiv_q_ui(result, result, 2);   // (n(3n-1))/2
}

// p = (n(3n-1)/2
void pentagonal_ui(mpz_t result, unsigned int ui)
{
    mpz_t n;
    mpz_init(n);
    mpz_init(result);
    mpz_set_ui(n, ui);
    mpz_mul_ui(result, n, 3);           // 3n
    mpz_sub_ui(result, result, 1);      // 3n-1
    mpz_mul(result, result, n);         // n(3n-1)
    mpz_tdiv_q_ui(result, result, 2);   // (n(3n-1))/2
    mpz_clear(n);
}

void test()
{
    mpz_t n, result;
    mpz_init(n);
    mpz_init(result);
    for (int i = 1; i <= 10; i++)
    {
        mpz_set_ui(n, i);
        pentagonal(result, n);
        printNumber("", result, " ");
    }
    printf("\n");
    for (int i = 1; i <= 15; i++)
    {
        mpz_set_ui(n, i);
        printf("isPentagonal(%d)==%d\n", i, isPentagonal(n));
    }
}
int main(int argc, char **argv)
{
    mpz_t p1, p2, p3, p4;
    test();
    // Locate a pair of pentagonal numbers that adds up to another pentagonal number
    for (int i = 1; i <= 999999; i++)
    {
        for (int distance = 1; distance <= 100; distance++)
        {
            mpz_init(p1);
            mpz_init(p2);
            mpz_init(p3);
            pentagonal_ui(p1, i);
            pentagonal_ui(p2, i + distance);
            mpz_add(p3, p1, p2);
            if (isPentagonal(p3))
            {
                mpz_init(p4);
                //printf("almost ");
                //printNumber("p1=", p1, " ");
                //printNumber("p2=", p2, " ");
                //printNumber("p3=", p3, "\n");
                mpz_add(p4, p3, p2);
                if (isPentagonal(p4))
                {
                    printf("MATCH!");
                    printNumber("p1=", p1, " ");
                    printNumber("p2=", p2, " ");
                    printNumber("p3=", p3, " ");
                    printNumber("p4=", p4, "\n");
                }
                mpz_clear(p4);
            }
            mpz_clear(p3);
            mpz_clear(p2);
            mpz_clear(p1);
        }
    }
    return 0;
}
